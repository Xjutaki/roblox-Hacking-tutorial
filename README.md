Туториал по Эксплоитингу в Роблокс
===================

туториал по скриптингу в Роблокс    [ Дискорд : --@Xjumu ]

## Инструменты
1 Вам нужен любой инжектор такие как [Milotic](https://milotic.xyz/) , [Valyse](https://valyse.net/) итд..

2 Роблоес с Майкрософт Магазин

3 И любая программа для Изменения / написания кода такая как Visual Studio code
  
## Основы Lua
Луа - это язык программирования. Языки программирования очень похожи на языки людей - вы переносите понятия из своей головы в слова, чтобы другие люди могли их понять. Компьютеры, в общем, не говорят на языках, кроме машинных инструкций (которые довольно трудоемки для написания), поэтому программисты придумали идею написания программ, которые читают разные виды языков программирования и выполняют соответствующие машинные инструкции. Таким образом, они упрощают общение с компьютером (или, в нашем случае, с TPT - большой предметно-ориентированной языковой моделью, на которой основан этот разговор).


# Переменные / Variables
Переменные это как коробка в которую вы можете положить свои вещи а так же Найти её по имени когда будет нужно

- Создаем Переменную
```lua
local A = 1
```
Итак. Мы создали Пременную под названием А, и дали ему число 1

- Мы можем вывести Значение нашей переменной в Консоль ( F9 )
Используем Комманду
```lua
print()
```

Что бы вывести содержание нашей  переменной в консоль мы должны засунуть нашу переменную в скобки
```lua
print(A)
```
также кроме чисел мы можем вписывать Текст то есть
```lua
local A = "Pososi"
```

# Разрешенные названия переменных
```lua
local A = 1 --// Можно
local thing = 2 --// Тоже можно
local BigNigg = 5 --// Переменная БольшойНиг хах.. Тоже можно
local and = 6 --// Нельзя , так как "and" это одна из функций
lcoal _and = 3 --// Можно
local and1 = 4 --// Тоже можно
local and_or = 7 --// Тоже можео так как это так называемый "Snake Case"

--[Snake case - это переменная с _ и в ней нету Больших букв]
```
# Комментарии Кода
вы наверное заметили что я использую -- при комментации 
```lua
-- Привет мир
```
так же есть вот такой вариант
```lua

--[[
Строка выше начинает многострочный комментарий.
Он не обращает внимания на переводы строк, а вместо этого ищет следующую строку:
]]

--[[
Обычно люди добавляют -- перед концом, чтобы выглядеть симметрично, или чтобы они могли просто удалить верхнюю строку, чтобы раскомментировать свой блок кода.
--]]
```
# Типы
```lua

"Hello, world" -- строка (string)
10.401 -- число (number)
2 -- число (number)
true -- булево значение (boolean)
nil -- nil (отсутствие значения)
{1, 2, 3} -- таблица (table)
math.floor -- функция (function)
```

**Строки**

Строки представляют собой просто текст.

Они начинаются с двойных кавычек `"` и заканчиваются двойными кавычками. Вы также можете использовать одиночные кавычки, или апострофы `'`, вместо двойных кавычек.

Внутри строки нельзя использовать переводы строк, но вместо фактического нажатия клавиши Enter вы можете ввести символьную последовательность `\n`, которая представляет собой символ новой строки.

Другие специальные символы могут быть найдены [здесь][pil2.4].

[pil2.4]: http://www.lua.org/pil/2.4.html

```lua
a = "Привет\nмир!"
```

**Nil**

`Nil` - это просто `nil`. Вы используете `nil` как маркер "здесь нет значения".

```lua
a = nil
```

**Булевы значения**

Булевы значения названы в честь булевой логики, которая названа в честь Джорджа Буля. Они представляют собой очень простое значение "true" (истина) или "false" (ложь), как переключатель, который может быть включен или выключен.

```lua
a = true
```

**Числа**

Числа - это не что-то особенное. Вы можете использовать как числа без дробей (целые числа), так и числа с дробями (числа с плавающей точкой).

```lua
a = 0.5
a = 4
```

**Таблицы**

Помимо обычных отдельных переменных, Lua может хранить несколько переменных в виде своего рода списка.

Представьте, что вы хотите хранить, например, список покупок. Или очередь людей. Вы не сможете сделать это с обычными переменными, вот где на помощь приходят таблицы!

**В качестве массивов**

Поскольку значение переменной больше не является одиночным значением, вы не можете просто использовать его в математике или в других целях - вам придется использовать специальный синтаксис для доступа к конкретному значению внутри этой таблицы.

```lua
mytable = {}
```

Это пустая таблица. В ней ничего нет.

```lua
mytable = {"CLNE", "DUST", "WATR"}
```

Это таблица с некоторыми текстовыми строками. Чтобы получить первую строку из таблицы, мы *обращаемся* к первому элементу таблицы. Это делается с помощью следующего синтаксиса:

```lua
mytable[1] -- результат: "CLNE"
```

Просто, не так ли? Мы добавляем квадратные скобки и указываем, какое значение мы хотим получить из таблицы. Что произойдет, если мы попытаемся получить что-то из таблицы, чего там нет?

```lua
mytable[100] -- результат: nil
```

Тут нет ничего нового. А что, если мы хотим сохранить что-то в этом конкретном месте? Мы можем просто присвоить значение данному синтаксису!

```lua
mytable[100] = "NEUT"
```

Теперь у вас есть таблица с первым, вторым, третьим и сто-тысячным значением. Ничего между ними нет. Как это происходит? Читайте далее...

**В качестве хешей**

Как вы, возможно, прочли из заголовка, таблицы могут быть как простыми списками значений, так и более сложной структурой, называемой хешами. Хеши - это самая простая структура данных, вот что они делают:

Они присваивают имя значению. Представьте себе [очень старую разновидность файловых шкафов.][fc] Там у вас есть множество вещей с небольшими ярлыками. Вы выбираете один из файлов на основе этих ярлыков и используете то, что получили. Хеши буквально - это файловые шкафы.

```lua
mytable = {}
mytable["moo"] = "cracker64"
mytable["potato"] = "jacob1"

-- mytable["moo"] возвращает "cracker64", например
```

И вот как использовать хеш. Просто. Вы также можете иметь обычный список, который также имеет некоторые случайные имена, присвоенные значениям.

```lua
mytable = {1, 2, 3}
mytable[1] = "moo"
mytable["filing cabinet"] = true

-- mytable теперь выглядит так: {1, 2, 3, "filing cabinet" = true}
```

Теперь, когда вы об этом подумаете, не являются ли обычные списки просто хешами, которые используют числа вместо строк для имен?

Дополнительное примечание: Вы также можете обращаться к именам хешей (которые являются допустимыми именами переменных) без кавычек или использования скобок, например:

```lua
mytable = {
  [1] = "beep boop",
 

 x = 15,
  y = 20,
  type = "DRAY"
}

tpt.log(mytable.type) -- хорошо
tpt.log(mytable.1) -- не хорошо
```

**Литералы таблиц**

Если вы видели выше, мы создали пустую таблицу с помощью `{}` и иногда добавляли значения в эту пустую таблицу с помощью `{1, 2, 3}`. Оба этих случая на самом деле называются "литералами таблиц" - это конструкции программирования, которые позволяют вам создавать таблицу, не используя тонны обычных присваиваний.

Вот как они выглядят в чистейшей форме. Таблицы в каждом блоке будут заканчиваться одним и тем же, за исключением того, что можно убрать больше частей и по-прежнему иметь то же самое значение.

```lua

mytable = {
  [1] = 1,
  [2] = 2,
  [3] = 3 
} 

-- то же самое
mytable = {1, 2, 3}

-- по-прежнему то же самое
mytable = {} 
mytable[1] = 1 
mytable[2] = 2 
mytable[3] = 3
```


```lua

mytable = {
  [1] = 1,
  [2] = 2,
  [3] = 3,
  ["potato"] = true 
}

mytable = {1, 2, 3, potato=true}

mytable = {1, 2, 3} 
mytable["potato"] = true

mytable = {} 
mytable["potato"] = true 
mytable[1] = 1 
mytable[2] = 2 
-- вы понимаете идею...
```


**Выражения**

Теперь я попробую объяснить понятие **выражений**. В ходе приведенного выше учебника вы, возможно, заметили, как различные виды синтаксиса могут "возвращать" значение. Например, когда вы присваиваете что-то переменной, правая сторона всегда должна иметь что-то, имеющее значение. Или, в случае `1 + 2`, это дает значение.

Выражения - это куски кода с значением, или конечным результатом. Например, код `2 + 3` имеет конечное значение, которое равно 5. Код `2 + a` также является выражением, даже если мы не можем сразу сказать, каково его значение без знания значения a.

... Говоря о чем, просто `a` также является выражением. Также `5` или `{}`. Все они являются кодом, возвращающим значение. Поэтому давайте используем эту новую терминологию в оставшейся части учебника!

**Функции**

Функции - это особый вид выражения, которое может ожидать значения (также называемые аргументами или параметрами) и возвращать другие значения. Они выполняют какой-то код в другом месте исходного файла и возвращают то, что функция вернет.

(Примечание: некоторые функции определены вне вашего исходного файла - это называется стандартной библиотекой или, в случае TPT, API.)

```lua

function add(x, y)
  -- если мы пишем позже add(1, 2)
  -- тогда x = 1
  -- и y = 2
  return x + y
  -- x + y вернет 1 + 2
  -- ... что равно 3
  -- следовательно, возвращаемое значение этого вызова функции равно 3. 
end

```

Вот крайне простая функция. Ее название - "add" (сложение).

Она принимает два значения (которые внутри функции будут называться x и y), и
возвращает значение выражения после слова "return".

Это выражение случайно добавля

ет x и y вместе, что и является тем, что мы хотим, чтобы функция делала!

Чтобы использовать эту функцию позже в коде, вы *вызываете* ее следующим образом:

```lua 
thing = add(1, 2)
```

Выражение `add(1, 2)` передает два "аргумента", 1 и 2, функции.
После этого функция находится и запускается сверху. Параметры 1 и 2
могут быть использованы внутри функции как x и y. Снаружи функции эти имена никогда не существуют!

Еще одно примечание: Функции могут возвращать более одного значения. Например:

```lua
function coordinatesOfParticle(index) 
  return tpt.get_property("x", index), tpt.get_property("y", index)
end

x_coord, y_coord = coordinatesOfParticle(15)
```

**Полезные выражения**

Вот несколько выражений (или, скорее, операторов, так как это называется символами в середине), которые вам могут понадобиться. Вещи в скобках описывают, какого типа должны быть выражения слева и справа.

**Математика**

```lua 
a + b -- (число и число) Сложение
a - b -- (число и число) Вычитание
a * b -- (число и число) Умножение
a / b -- (число и число) Деление
-a    -- (число и число) Отрицание (-5, например)
```

**Сравнение**

Вы можете сравнивать две переменные, и эти операторы будут возвращать логическое значение в зависимости от конечного значения. Это невероятно полезно, например, в разветвлениях!

```lua
a > b  -- (число и число) true, если a больше b
a < b  -- (число и число) true, если a меньше b

a >= b -- (число и число) true, если a больше или равно b
a <= b -- (число и число) true, если a меньше или равно b

a == b -- (любые типы) true, если a и b - одинаковые объекты или по крайней мере равны
a ~= b -- (любые типы) true, если a и b - не одинаковые объекты и не равны
```

**Логика булевых значений**

Есть множество логических операторов, которые полезны для комбинирования вышеуказанных выражений в одно единственное выражение. Например, если вы хотите проверить, что `(a + b > 10) и (a + b < 15)`, то ... это именно то, что вы напишете. Звучит просто, верно?

Также есть понятие **ложные** (falsey) и **истинные** (truthy) значения. Это значения, которые не являются буквально типом `boolean`, но как бы подходят под него. Например, `nil` - единственное ложное значение. Если вы включите его в логику ниже, это практически эквивалентно `false`, хотя это и не значениe типа `boolean`.

Любое другое значение является истинным (truthy), что означает, что вы можете проверить наличие переменной без использования операторов сравнения.

**Отрицание**

```lua
not a    -- (любое значение) true, если a - ложное значение
```

**Логическое "и"**

```lua
a and b  -- (любые значения) true, если и a, и b истинны
```

**Логическое "или"**

```lua
a or b   -- (любые значения) true, если либо a, либо b, либо оба истин

ны
```

На самом деле, это больше похоже на то, что ниже. Это называется "короткозамкнутой" логикой, что означает, что парсер может остановить чтение остальной части логического выражения, когда первая часть уже дает вам конечное значение. Вы можете использовать это свойство во многих трюках.

**Логическое "и" (короткозамкнутое)**

```lua
a and b -- (любые значения) b, если a - истинно, в противном случае a
```

**Логическое "или" (короткозамкнутое)**

```lua
a or b  -- (любые значения) a, если a - истинно, в противном случае b

-- пример трюка: назначьте a пустой таблице только если a не определено ранее
-- помните, как "nil" - это ложное значение? если a не определено, a равно nil, поэтому
-- "a or {}" будет вычислено как {}.
a = a or {}
```

### Ветвление (Branching)

Иногда вам может понадобиться что-то сделать в зависимости от выражения. Например, вы можете хотеть увеличить скорость машины **если** машина ниже лимита скорости, но уменьшить ее скорость, если она ниже него.

Это легко можно сделать, используя операторы ветвления в Lua.

```lua
speed = 30
if speed < 45 then
  speed = speed + 10
end
```

Это очень простой оператор ветвления: если выражение `speed < 45` истинно, то `speed` увеличивается на 10. В противном случае код игнорируется.

Если вы хотите написать что-то для выполнения в противном случае, вы можете использовать ключевое слово `else`:

```lua
speed = 30
if speed < 45 then
  speed = speed + 10
else 
  speed = speed - 10
end
```

Блок else применяется только в том случае, если любые выражения перед ним не применяются.

Если вы хотите написать более одной ветви, например, чтобы оставаться на той же скорости, когда скорость находится между 45 и 60 единицами, вы можете добавить оператор `elseif` перед концом. Он использует другое выражение, которое проверяется только тогда, когда все if/elseif перед ним не выполнены.

Вы можете иметь несколько else-ifs в одном операторе if, что означает, что у вас может быть буквально бесконечное количество различных ветвей кода.

```lua
speed = 30

if speed < 45 then
  speed = speed + 10

elseif speed > 45 and speed < 60 then
  -- ничего не делаем

elseif speed > 60 and speed < 75 then
  -- замедляемся медленно
  speed = speed - 5

else
  -- резкое замедление
  speed = speed - 10
end
```

### Циклы (Looping)

Что, если у вас есть таблица, и вы хотите пройти по каждому элементу один раз, выполнив на нем один и тот же код, какие у вас есть варианты?

...

Я отвечу за вас.  
Во-первых, вы можете просто запустить код один раз для каждого индекса:

```lua
mytable = {"ARAY", "BRAY", "CRAY", "DRAY", "ERAY"}

tpt.set_property("temp", 1000, mytable[1])

tpt.set_property("temp", 1000, mytable[2])

tpt.set_property("temp", 1000, mytable[3])

tpt.set_property("temp", 1000, mytable[4])

tpt.set_property("temp", 1000, mytable[5])
```

Довольно неприятно, не так ли? Мы также могли бы определить функцию с нашим кодом и вызвать ее с разным входом из таблицы каждый раз:

```lua 

mytable = {"ARAY", "BRAY", "CRAY", "DRAY", "ERAY"}

function doThing(i)
  tpt.set_property("temp", 1000, mytable[i])
end

doThing(1)
doThing(2)
doThing(3)
doThing(4)
doThing(5)
```

... Это становится старым быстро. Как же нам автоматизировать это?

#### Циклы while

Циклы while - это самый простой вид цикла: делайте все внутри блока кода до тех пор, пока выражение истинно. Когда оно становится ложным, больше ничего не выполняется.

```lua
i = 0

-- i = i + 2. когда i равно 100 или больше, цикл перестает выполняться, и остальной код выполняется.
while i < 100 do
  i = i + 2
end

-- выполняется до тех пор, пока i + 1 меньше 0, затем останавливается
while i + 1 >= 0 do
  i = (i / 2) - 1
end

-- Постоянно добавляем 1 к i
-- К тому же, засоряем журнал TPT сообщениями "lol".
while true do
  i = i + 1
  tpt.log("lol")
end
```

```lua
while true do
  i = i + 1
  if i % 1000 == 0 then
    -- новый оператор: прервать выполнение цикла!
    break
  end
end
```

Просто, не так ли?

Циклы while чрезвычайно практич

ны, но начинающие часто создают бесконечные циклы по ошибке. Поэтому циклы for часто более практичны.

#### Циклы repeat-until

Они точно такие же, как циклы while, за исключением того, что они перевернуты вверх дном. Проверяемый оператор должен оставаться *ложным*, а не истинным, и значение проверяется в конце итерации, а не в начале.

Например, эти два цикла абсолютно идентичны:

```lua
while true do 
  if not (i < 1000) then
    break
  end
  i = i + 1
end

while i < 1000 do
  i = i + 1
end
```

... но в то же время *эти* два цикла тоже одинаковы:

```lua
while true do
  i = i + 1
  if i > 1000 then
    break
  end
end

repeat
  i = i + 1
until i > 1000
```

Поняли?

#### Циклы стиля C

(Их называют циклами стиля C, потому что они выглядят похожими на популярный язык программирования C.)

Циклы for называют так из-за того, что обычно их читают как "для каждого i от 1 до 500 сделай это".

В любом случае. Вот как это сделать.

```lua
for i=1, 5, 1 do
  -- значение i будет разным на каждой итерации
  doThing(i)
end
```

(Примечание: переменная не обязательно должна называться i или одной буквой. `i` часто используется, потому что слово "iterable" начинается с буквы I.)

Синтаксис более прост, чем может показаться: сначала мы инициализируем `i` каким-то значением (в данном случае `i = 1`).

После запятой мы говорим, что значение `i` не может быть больше 5.

После еще одной запятой мы говорим, что мы хотим, чтобы `i` увеличивался на 1 каждый раз.

Вы можете реализовать этот цикл `for` в цикле `while` следующим образом:

```lua
i = 1
while i < 5 do
  doThing(i)
  i = i + 1
end
```

## Ну чо выучили основы а теперь погнали хакать роблокс

- Давайте попробуем изменить скорость игрока
- для этого вам нужен будет DarlDex это скрипт который показывает все файлы Плейса роблокс и помогает прописать путь к чему либо
```lua
--// DarkDexV3
loadstring(game:HttpGet("https://raw.githubusercontent.com/Babyhamsta/RBLX_Scripts/main/Universal/BypassedDarkDexV3.lua", true))()
```

прописываем путь к модельке игрока
```lua
local player = game.Players.LocalPlayer
local character = player.Character.Humanoid

character.WalkSpeed = 500
```

так же мы можем поменять WalkSpeed на JumpPower
и таким образом мы можем менять скорость , Сила прыжка
```lua
local player = game.Players.LocalPlayer
local character = player.Character.Humanoid

character.JumpPower = 500
```
